<template hx-get="components/board.html" hx-swap="outerHTML" hx-trigger="load"></template>
<template hx-get="components/score.html" hx-swap="outerHTML" hx-trigger="load"></template>
<template hx-get="components/piece.html" hx-swap="outerHTML" hx-trigger="load"></template>
<template id="tmpl-game">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :host {
            --baseunit: 1em;
        }

        game-piece.selected {
            outline: 1px solid red;
        }

        :host {
            display: grid;
            grid-auto-flow: row dense;
            grid-template-columns: 100%;
            grid-template-rows: auto 9fr 5fr;
            gap: var(--baseunit);
            /*non-grid setings*/
            aspect-ratio: 1/2;
            position: relative;
            padding-top: var(--baseunit) !important;
            padding-bottom: var(--baseunit) !important;
            /* debug settings */
            /* background-color: rgba(255, 0, 255, 50%); */
        }

        @media (min-aspect-ratio: 1/2) {
            :host {
                top: 0;
                left: calc(50% - 25vh);
                height: 100vh;
                width: 50vh;
            }
        }

        @media (aspect-ratio: 1/2) {
            :host {
                width: 100vw;
                height: 200vw;
                top: calc(100% - 200vw);
                left: 0;
            }
        }

        @media (max-aspect-ratio: 1/2) {
            :host {
                width: 100vw;
                height: 200vw;
                top: calc(100% - 200vw);
                left: 0;
            }
        }

        .piecebuffer {
            outline: 1px solid var(--color-text);
            display: flex;
            justify-content: space-between;
            width: 100%;
            height: min-content;
            margin-top: auto;
        }

        game-piece {
            margin-left: 0.5vw;
            margin-right: 0.5vw;
            margin-top: .5vh;
            margin-bottom: .5vh;
            width: 33% !important;
        }
    </style>
    <game-score id="score"></game-score>
    <div id="space-between"></div>
    <game-board id="board"></game-board>
    <div class="piecebuffer">
        <game-piece id="piece-1"></game-piece>
        <game-piece id="piece-2"></game-piece>
        <game-piece id="piece-3"></game-piece>
    </div>
</template>
<script id="scrpt-game">
    function indexTo1D(row, col) {
        const r = Math.max(0, Math.min(9, row));
        const c = Math.max(0, Math.min(9, col));
        return r * 9 + c;
    }
    function indexTo2D(index) {
        const idx = Math.max(0, Math.min(80, index));
        const col = idx % 9;
        const row = (idx - col) / 9
        return {
            row: row,
            col: col,
        }
    }

    const gameElementName = 'game-wrap';
    const gameTemplateId = 'tmpl-game';
    const gameTemplate = document.getElementById(gameTemplateId);
    class CustomGameElement extends HTMLElement {
        peicePlacedHandler(e) {
            this.score.value += e.detail.deltaScore;
            const pieces = this.pieces;

            // Check for clearables
            this.score.value += this.board.clear();

            // Check if i need to refill the piece-buffer
            let refill = true;
            for (let i = 0; i < pieces.length; i++) { refill &= pieces[i].shapeId === -1; }
            if (refill) { this.fillPieceBuffer() }
        }
        clickHandler(event) {
            console.debug(this.localName, "clickHandler()");
            this.restart();
            this.removeEventListener("click", this.clickHandler)
        }
        connectedCallback() {
            console.debug(this.localName, "connectedCallback()");
            let templateContent = gameTemplate.content;

            this.attachShadow({ mode: "open" });
            this.shadowRoot.appendChild(templateContent.cloneNode(true));
            this.addEventListener("click", this.clickHandler)
            document.addEventListener("pieceplaced", e => this.peicePlacedHandler(e));
        }
        constructor() {
            super();
            console.debug(this.localName, "constructor()");
            this.seed = sfc32.getSeed();
            this.rand = new sfc32(this.seed);
        }
        get score() {
            return this.shadowRoot.getElementById('score');
        }
        get board() {
            return this.shadowRoot.getElementById('board');
        }
        get pieces() {
            return [
                this.shadowRoot.getElementById('piece-1'),
                this.shadowRoot.getElementById('piece-2'),
                this.shadowRoot.getElementById('piece-3'),
            ]
        }

        fillPieceBuffer() {
            this.pieces[0].shapeId = shapeIds[this.rand.nextInt() % shapeIds.length];
            this.pieces[1].shapeId = shapeIds[this.rand.nextInt() % shapeIds.length];
            this.pieces[2].shapeId = shapeIds[this.rand.nextInt() % shapeIds.length];
        }
        restart() {
            console.log(this.localName, "restart()");
            this.seed = sfc32.getSeed();
            this.rand = new sfc32(this.seed);
            this.fillPieceBuffer();
        }
    }

    customElements.define(gameElementName, CustomGameElement);
</script>