<template id="tmpl-game-board">
    <style>
        :host {
            --cell-empty-opacity: 36%;
            --cell-color-dark: rgba(0, 0, 0, var(--cell-empty-opacity));
            --cell-color-light: rgba(255, 255, 255, var(--cell-empty-opacity));
            --cell-border-color: rgba(153, 145, 102, 100%);
            --cell-space: calc(min(0.25vh, 0.5vw)/2 + 0.49px);
            /**/
            /* box-shadow: 8px 8px 36px 16px rgba(0,0,0,0.43) inset; */
            --cell-shadow: var(--cell-space) var(--cell-space) calc(4 * var(--cell-space)) calc(2 * var(--cell-space)) rgba(0, 0, 0, .66) inset;
            /* --cell-highlight: 0 0 calc(12 * var(--cell-space)) 0 rgba(255, 255, 255, 100%) inset; */
            --cell-highlight: var(--cell-space) var(--cell-space) calc(4 * var(--cell-space)) calc(2 * var(--cell-space)) rgba(255, 255, 255, .66) inset;
        }

        :host {
            aspect-ratio: 1/1;
            display: grid;
            grid-auto-flow: row dense;
            grid-auto-columns: 1fr;
            grid-auto-rows: 1fr;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr 1fr;
            gap: 0px 0px;
            grid-template-areas:
                ". . . . . . . . ."
                ". . . . . . . . ."
                ". . . . . . . . ."
                ". . . . . . . . ."
                ". . . . . . . . ."
                ". . . . . . . . ."
                ". . . . . . . . ."
                ". . . . . . . . ."
                ". . . . . . . . .";
            background-color: rgba(100, 45, 0, 100%);
            background-blend-mode: multiply;
            border: var(--cell-space) solid var(--cell-border-color);
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .board-cell {
            display: block;
            aspect-ratio: 1/1;
            text-align: center;
            justify-content: center;
            border: var(--cell-space) solid var(--cell-border-color);
            border-radius: 10%;
            background-color: magenta;
            background-blend-mode: multiply;
            box-shadow: var(--cell-shadow);
            overflow: hidden;
        }

        /* Even Groups */
        .board-cell[grp="0"],
        .board-cell[grp="2"],
        .board-cell[grp="4"],
        .board-cell[grp="6"],
        .board-cell[grp="8"] {
            background-color: var(--cell-color-dark);
        }

        /* Uneven Groups */
        .board-cell[grp="1"],
        .board-cell[grp="3"],
        .board-cell[grp="5"],
        .board-cell[grp="7"] {
            background-color: var(--cell-color-light);
        }

        /* Cell State*/
        .board-cell.highlight {
            box-shadow: var(--cell-highlight) !important;
        }

        .board-cell[state="0"]>.board-cell-img {
            display: none;
        }

        .board-cell-img {
            background-color: hsla(30, 100%, 24%, 100%);
            max-width: 100%;
            max-height: 100%;
            margin: 0;
            padding: 0;
        }
    </style>
</template>
<template id="tmpl-game-boardcell">
    <div idx="0" grp="0" row="0" col="0" state="0" class="board-cell">
        <img src="/img/block_white.svg" alt="block white" class="board-cell-img">
    </div>
</template>
<script id="scrpt-game-board">
    function calcGroup(row, col) {
        const r = Math.max(0, Math.min(9, row));
        const c = Math.max(0, Math.min(9, col));
        const gr = Math.floor(r / 3) * 3;
        const gc = Math.floor(c / 3);
        return gr + gc;
    }
    function enableCell(cell) {
        // TODO Check cell is element
        // TODO Check cell has state attribute
        cell.setAttribute("state", 1);
    }
    function disableCell(cell) {
        // TODO Check cell is element
        // TODO Check cell has state attribute
        cell.setAttribute("state", 0);
    }
    function toggleCell(cell) {
        console.debug("toggleCell(", cell, ")");
        // TODO Check cell is element
        // TODO Check cell has state attribute
        let cellState = parseInt(cell.getAttribute("state"));
        if (cellState === 0) {
            enableCell(cell);
        } else if (cellState === 1) {
            disableCell(cell);
        } else {
            console.error("Invalid cell state", cellState, "on element: ", cell);
        }
    }

    const boardElementName = 'game-board';
    const boardTemplateId = 'tmpl-game-board';
    const boardTemplate = document.getElementById(boardTemplateId);
    const cellTemplateId = 'tmpl-game-boardcell';
    const cellTemplate = document.getElementById(cellTemplateId);
    var blockSize = -1;
    class CustomBoardElement extends HTMLElement {

        litCells = [];
        removeAllLit() {
            console.debug(this.localName, "removeAllHighlights()")
            let cell = undefined;
            while (this.litCells.length > 0) {
                cell = this.litCells.pop();
                cell.classList.remove('highlight');
            }
        }
        lightCell(cell) {
            cell.classList.add('highlight')
            this.litCells.push(cell);
        }
        mouseenterCellHandler(e) {
            if (CustomPieceElement.selected === undefined) { return; }

            const cell0 = e.target;
            const shadowRoot = cell0.getRootNode();
            const board = shadowRoot.host;
            board.removeAllLit();
            let r0 = parseInt(cell0.getAttribute('row'));
            let c0 = parseInt(cell0.getAttribute('col'));
            const shape = CustomPieceElement.selected.shape;

            let offset = shape[0];
            let r_mid = offset.r;
            let c_mid = offset.c;
            for (let i = 1; i < shape.length; i++) {
                offset = shape[i];
                r_mid += offset.r;
                c_mid += offset.c;
            }
            r_mid = Math.floor(r_mid / shape.length);
            c_mid = Math.floor(c_mid / shape.length);
            r0 -= r_mid;
            c0 -= c_mid;
            console.debug("r_mid:", r_mid, "c_mid", c_mid);
            let cell = undefined;
            for (let i = 0; i < shape.length; i++) {
                offset = shape[i];
                cell = shadowRoot.querySelector(`.board-cell[row="${offset.r + r0}"][col="${offset.c + c0}"][state="0"]`)
                if (TypeChecker.isNullOrUndefined(cell)) {
                    board.removeAllLit();
                    return;
                }
                board.lightCell(cell);
            }
        }
        clickCellHandler(e) {
            const board = e.target.getRootNode().host;
            const shape = CustomPieceElement.selected.shape;
            console.debug("shape:", shape);
            console.debug("board.litCells:", board.litCells);
            if (board.litCells.length === shape.length) {
                let cell = undefined;
                while (board.litCells.length > 0) {
                    cell = board.litCells.pop();
                    cell.classList.remove('highlight');
                    cell.setAttribute("state", 1);
                }
                CustomPieceElement.placeSelected();
            }
        }
        createCells() {
            console.debug(this.localName, "createCells()");
            for (let row = 0; row < 9; row += 1) {
                for (let col = 0; col < 9; col++) {
                    let idx = indexTo1D(row, col);
                    let grp = calcGroup(row, col);
                    let clone = cellTemplate.content.cloneNode(true);
                    let cell = clone.firstElementChild;
                    cell.setAttribute("idx", idx)
                    cell.setAttribute("grp", grp)
                    cell.setAttribute("row", row);
                    cell.setAttribute("col", col);
                    cell.addEventListener("mouseenter", this.mouseenterCellHandler, true)
                    cell.addEventListener("click", this.clickCellHandler, true)
                    this.shadowRoot.appendChild(cell);
                }
            }
        }
        getCellByIndex(index) {
            const idx = Math.min(80, Math.max(0, index));
            return this.shadowRoot.querySelector(`.board-cell[idx="${idx}"]`);
        }
        get cells() {
            return Array.from(this.shadowRoot.querySelectorAll('.board-cell'));
        }

        updateBlockSize() {
            console.debug(this.localName, "updateBlockSize()");
            const cell = this.getCellByIndex(0);
            blockSize = (cell.clientWidth + cell.clientHeight) / 2;
        }
        resizeHandler(event) {
            this.updateBlockSize();
        }

        reset() {
            const cells = this.cells;
            for (let i = 0; i < this.cells.length; i++) {
                cells[i].setAttribute("state", 0);
            }
        }

        getGroups() {
            return [
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="0"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="1"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="2"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="3"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="4"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="5"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="5"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="6"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="7"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[grp="8"]')),
            ]
        }
        getRows() {
            return [
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="0"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="1"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="2"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="3"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="4"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="5"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="5"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="6"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="7"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[row="8"]')),
            ]
        }
        getColoumns() {
            return [
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="0"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="1"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="2"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="3"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="4"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="5"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="5"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="6"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="7"]')),
                Array.from(this.shadowRoot.querySelectorAll('.board-cell[col="8"]')),
            ]
        }

        /** clears all clearable cells. returns the delta score*/
        clear() {
            let clearableSections = [];
            let section = undefined;
            // GROUPS
            const grps = this.getGroups();
            for (let i = 0; i < grps.length; i++) {
                section = grps[i];
                let filled = true;
                for (let j = 0; j < section.length; j++) {
                    const state = parseInt(section[j].getAttribute("state"));
                    if (state !== 1) {
                        filled = false;
                        break;
                    }
                }
                if (filled) { clearableSections.push(section); }
            }
            section = undefined;

            // ROWS
            const rows = this.getRows();
            for (let i = 0; i < rows.length; i++) {
                section = rows[i];
                let filled = true;
                for (let j = 0; j < section.length; j++) {
                    const state = parseInt(section[j].getAttribute("state"));
                    if (state !== 1) {
                        filled = false;
                        break;
                    }
                }
                if (filled) { clearableSections.push(section); }
            }
            section = undefined;

            // COLUMNS
            const cols = this.getColoumns();
            for (let i = 0; i < cols.length; i++) {
                section = cols[i];
                let filled = true;
                for (let j = 0; j < section.length; j++) {
                    const state = parseInt(section[j].getAttribute("state"));
                    if (state !== 1) {
                        filled = false;
                        break;
                    }
                }
                if (filled) { clearableSections.push(section); }
            }
            section = undefined;

            // DISABLING
            let result = 0;
            for (let i = 0; i < clearableSections.length; i++) {
                section = clearableSections[i];
                for (let j = 0; j < section.length; j++) {
                    result += 1;
                    disableCell(section[j]);
                }
            }
            return result;
        }

        connectedCallback() {
            console.debug(this.localName, "connectedCallback()");
            let templateContent = boardTemplate.content;

            let shadowRoot = this.attachShadow({ mode: "open" });
            shadowRoot.appendChild(templateContent.cloneNode(true));
            this.createCells();

            window.addEventListener("resize", (e) => this.resizeHandler(e))
            this.updateBlockSize();
        }
        constructor() {
            super();
            console.debug(this.localName, "constructor()");
        }
    }

    customElements.define(boardElementName, CustomBoardElement);
</script>